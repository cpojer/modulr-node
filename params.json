{"name":"modulr","body":"modulr\r\n======\r\n\r\nResolves and concatenates [CommonJS module][1] dependencies for use in the browser. It's a port of [`modulr`][2] from Ruby to [node.js][3] and is based on [`module-grapher`][4], a node module which resolves dependencies through recursive static analysis.\r\n\r\nInstall\r\n-------\r\n\r\n`modulr` is available as an NPM module.\r\n\r\n    $ npm install modulr\r\n\r\nUsage\r\n-----\r\n\r\n`modulr` accepts the main module's identifier and an optional config object as arguments which get passed to `module-grapher`. It returns a result object whose `output` property is a string containing [a small runtime][5] and the concatenated modules sources. Optionally, this output can be minified and the module identifiers resolved server-side.\r\n\r\n```javascript\r\nrequire('modulr').build('foo', {\r\n  paths: ['./lib', './vendor'], // defaults to ['.']\r\n  root: 'path/to/package/root/' // defaults to process.cwd()\r\n  minify: true,                 // defaults to false\r\n  resolveIdentifiers: true,     // defaults to false\r\n  environment: 'prod' // or 'dev', defaults to undefined\r\n}, callback);\r\n\r\n// Dump the output to `main.js`.\r\nfunction callback (err, result) {\r\n  if (err) { throw err; }\r\n  require('fs').writeFileSync('/path/to/main.js', result.output, 'utf8');\r\n}\r\n```\r\n\r\n`modulr` can also accepts a [CommonJS package][6] or its `package.json` file as argument. In which case it uses the JSON file's `main` value as entry point, the package's dir as root, and picks the rest of its options from the JSON file's `modulr` namespace.\r\n\r\n```javascript\r\nrequire('modulr').buildFromPackage('path/to/package', callback);\r\n```\r\n\r\n### Development Environments\r\n\r\n`modulr` provides a development environment. It is enabled by setting the config option `environment` to `\"dev\"`:\r\n\r\n```javascript\r\nrequire('modulr').build('foo', { environment: 'dev' }, callback);\r\n```\r\nThis does essentially two things.\r\n\r\n1. It sets the global variable `__DEV__` to `true`. This allows adding development-only code (e.g. logging) that is completely stripped out of production builds, e.g.:\r\n```javascript\r\nif (__DEV__) { console.log('Module Foo loaded.'); }\r\n```\r\n\r\n2. It adds [`sourceURL` comments](http://blog.getfirebug.com/2009/08/11/give-your-eval-a-name-with-sourceurl/) to each modules. Rendering engines that support these (at least Gecko and WebKit) will give original file names and line numbers to thrown errors even though all modules are packaged in a single file.\r\n\r\n### Minification\r\n\r\n`modulr` uses [Uglify](https://github.com/mishoo/UglifyJS/) to optionally minify the output. To enable minification, set the `minify` config option to `true`. Note that minification is not compatible with the `\"dev\"` environment.\r\n\r\n```javascript\r\nrequire('modulr').build('foo', { minify: 'true' }, callback);\r\n```\r\n\r\n### Lazy evaluation\r\n\r\n[Lazy evaluation](http://calendar.perfplanet.com/2011/lazy-evaluation-of-commonjs-modules/) is a technique which allows delaying parsing and evaluation of modules until they are needed (for example, following a user action) while keeping a synchronous programming model.\r\n\r\nTo lazy eval modules, pass a list of absolute module IDs in the configuration object.\r\n\r\n```javascript\r\nrequire('modulr').build('foo', {\r\n  lazyEval: ['path/to/module/bar', 'path/to/baz']\r\n}, callback);\r\n```\r\n\r\nor in the `package.json` file:\r\n\r\n```javascript\r\n{\r\n  \"modulr\": {\r\n    \"lazyEval\": [\"path/to/bar\", \"path/to/baz\"]\r\n  }\r\n}\r\n```\r\n\r\n### Resolving identifiers at build time\r\n\r\nCommonJS module identifiers can be absolute or relative. Relative identifiers are simplify development but have an extra runtime cost: the path to the module's identifier has to be calculated every time the module is required, and a context aware require function has to be created for every module.\r\n\r\nIn order to avoid that extra cost, `modulr` is able to resolve identifiers at build time which produces modified builds which only contain absolute identifiers and uses a [lighter runtime](https://github.com/tobie/modulr-node/blob/master/assets/modulr.sync.resolved.js). To enable this option, set the `resolveIdentifiers` config option to `true`:\r\n\r\n```javascript\r\nrequire('modulr').build('foo', { resolveIdentifiers: true }, callback);\r\n```\r\n\r\n### Instrumenting Performance\r\n\r\nAs applications become increasingly complex, startup time tends to suffer. While `modulr` helps mitigate this through optimizations such as resolving identifiers at build time or lazy evaluation, it's sometimes useful to be able to do some serious auditing and find out which modules slow down startup time.\r\n\r\nThat's what `modulr`'s instrumentPerformance config option enables. Turn it on like so:\r\n\r\n```javascript\r\nrequire('modulr').build('foo', { instrumentPerformance: true }, callback);\r\n```\r\n\r\nThis adds a slew of data to the `modulr.perf` object available in the global scope (for example, through the console). This data is of the form:\r\n\r\n```javascript\r\n{\r\n  \"start\": 1334878573462,            // All times are in ms.\r\n  \"defineStart\": 1334878573462,      //\r\n  \"defineEnd\": 1334878573464,        //\r\n  \"requireMainStart\": 1334878573464, //\r\n  \"modules\": {                       // Object containing all defined modules.\r\n    \"foo\": {                         //\r\n      \"count\": 0                     // Module \"foo\" has not been required yet.\r\n    },                               //\r\n                                     //\r\n    \"main\": {                        // Module \"main\" has been required once.\r\n      \"count\": 1,                    // Evaluation of that module and it's\r\n      \"left\": 1,                     // dependencies took 16 ms.\r\n      \"start\": 1334878573464,        // Notice the use of nested sets to\r\n      \"right\": 4,                    // store initialization order.\r\n      \"end\": 1334878573480           //\r\n    },                               //\r\n                                     //\r\n    \"bar\": {                         // Module \"bar\" has been required twice.\r\n      \"count\": 2,                    // It was lazy evaluated.\r\n      \"left\": 2,                     //\r\n      \"start\": 1334878573466,        //\r\n      \"evalStart\": 1334878573466,    // Lazy evaluation took 12 ms.\r\n      \"evalEnd\": 1334878573478,      //\r\n      \"right\": 3,                    //\r\n      \"end\": 1334878573480           //\r\n    }                                //\r\n  },                                 //\r\n  \"requireMainEnd\": 1334878573480,   //\r\n  \"end\": 1334878573480               //\r\n}\r\n```\r\n\r\nTo visualize this data, just copy and paste it (or in modern browsers, simply drag and drop the JSON file) onto [this page](http://tobie.github.com/modulr-node/perf.html). You'll get a beautiful waterfall chart of your application's initialization stage thanks to a little bit of [d3.js](http://mbostock.github.com/d3/) magic.\r\n\r\nLicense\r\n-------\r\n\r\nYour choice of [MIT or Apache, Version 2.0 licenses][7]. `modulr` is copyright 2010 [Tobie Langel][8].\r\n\r\n[1]: http://wiki.commonjs.org/wiki/Modules/1.1\r\n[2]: https://github.com/tobie/modulr\r\n[3]: http://nodejs.org\r\n[4]: https://github.com/tobie/module-grapher\r\n[5]: https://github.com/tobie/modulr-node/blob/master/assets/modulr.sync.js\r\n[6]: http://wiki.commonjs.org/wiki/Packages/1.1\r\n[7]: https://raw.github.com/tobie/modulr-node/master/LICENSE\r\n[8]: http://tobielangel.com\r\n\r\n","tagline":"Resolves and concatenates CommonJS module dependencies for use in the browser.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}